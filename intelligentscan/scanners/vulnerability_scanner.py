"""
Vulnerability Scanner for IntelligentScan
Detects security vulnerabilities in codebases including:
- Log4j vulnerabilities
- Hardcoded secrets/credentials
- SQL injection risks
- XSS vulnerabilities
- Insecure dependencies
"""

import os
import re
import ast
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime
import json


class VulnerabilityScanner:
    """Scans code for security vulnerabilities"""

    # Vulnerability patterns
    VULNERABILITY_PATTERNS = {
        "log4j": {
            "description": "Log4j vulnerability (CVE-2021-44228)",
            "severity": "critical",
            "patterns": [
                r"org\.apache\.logging\.log4j",
                r"log4j-core.*2\.([0-9]|1[0-4])\.",  # Vulnerable versions 2.0-2.14
                r"\$\{jndi:",  # JNDI lookup pattern
            ],
            "file_patterns": ["pom.xml", "build.gradle", "*.java", "*.xml"]
        },
        "hardcoded_secrets": {
            "description": "Hardcoded credentials or API keys",
            "severity": "critical",
            "patterns": [
                r"password\s*=\s*['\"][^'\"]{3,}['\"]",
                r"api[_-]?key\s*=\s*['\"][^'\"]{10,}['\"]",
                r"secret\s*=\s*['\"][^'\"]{10,}['\"]",
                r"aws[_-]?access[_-]?key[_-]?id\s*=\s*['\"][A-Z0-9]{20}['\"]",
                r"private[_-]?key\s*=\s*['\"][-BEGIN RSA PRIVATE KEY-]",
                r"token\s*=\s*['\"][a-zA-Z0-9_-]{20,}['\"]",
            ],
            "file_patterns": ["*.py", "*.js", "*.java", "*.go", "*.rb", "*.php", "*.cs"]
        },
        "sql_injection": {
            "description": "Potential SQL injection vulnerability",
            "severity": "high",
            "patterns": [
                r"execute\(['\"].*\%s.*['\"].*\%",  # Python string formatting in SQL
                r"execute\(.*\+.*\)",  # String concatenation in SQL
                r"SELECT.*FROM.*WHERE.*\+",  # SQL concatenation
                r"cursor\.execute\(.*format\(",  # Format string in SQL
            ],
            "file_patterns": ["*.py", "*.java", "*.php", "*.js"]
        },
        "command_injection": {
            "description": "Potential command injection",
            "severity": "high",
            "patterns": [
                r"os\.system\(.*\+",
                r"subprocess\.call\(.*\+",
                r"eval\(",
                r"exec\(",
            ],
            "file_patterns": ["*.py", "*.js", "*.rb", "*.php"]
        },
        "xss_vulnerability": {
            "description": "Potential Cross-Site Scripting (XSS) vulnerability",
            "severity": "medium",
            "patterns": [
                r"innerHTML\s*=",
                r"document\.write\(",
                r"dangerouslySetInnerHTML",
            ],
            "file_patterns": ["*.js", "*.jsx", "*.ts", "*.tsx", "*.html"]
        },
        "insecure_random": {
            "description": "Use of insecure random number generator",
            "severity": "medium",
            "patterns": [
                r"Math\.random\(\)",
                r"random\.random\(\)",  # Python's random (not cryptographically secure)
            ],
            "file_patterns": ["*.js", "*.py", "*.java"]
        }
    }

    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path)
        self.vulnerabilities_found = []
        self.files_scanned = 0
        self.start_time = None

    async def scan(self, vulnerability_types: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Perform vulnerability scan

        Args:
            vulnerability_types: Specific vulnerabilities to check, or None for all

        Returns:
            Scan results dictionary
        """
        self.start_time = datetime.now()
        self.vulnerabilities_found = []
        self.files_scanned = 0

        # Determine which vulnerability types to scan
        if vulnerability_types:
            vuln_types_to_scan = {
                vtype: pattern
                for vtype, pattern in self.VULNERABILITY_PATTERNS.items()
                if vtype in vulnerability_types
            }
        else:
            vuln_types_to_scan = self.VULNERABILITY_PATTERNS

        # Scan repository
        for vuln_type, vuln_config in vuln_types_to_scan.items():
            await self._scan_vulnerability_type(vuln_type, vuln_config)

        # Compile results
        duration = (datetime.now() - self.start_time).total_seconds()

        severity_breakdown = self._calculate_severity_breakdown()
        files_affected = len(set(v["file"] for v in self.vulnerabilities_found))

        return {
            "vulnerabilities_found": self.vulnerabilities_found,
            "severity_breakdown": severity_breakdown,
            "files_affected": files_affected,
            "files_scanned": self.files_scanned,
            "scan_metadata": {
                "start_time": self.start_time.isoformat(),
                "duration_seconds": duration,
                "vulnerability_types_checked": list(vuln_types_to_scan.keys())
            }
        }

    async def _scan_vulnerability_type(self, vuln_type: str, vuln_config: Dict[str, Any]):
        """Scan for a specific vulnerability type"""

        file_patterns = vuln_config["file_patterns"]
        patterns = vuln_config["patterns"]

        # Find matching files
        matching_files = []
        for pattern in file_patterns:
            matching_files.extend(self.repo_path.rglob(pattern))

        # Scan each file
        for file_path in matching_files:
            # Skip binary files, hidden files, and common ignore patterns
            if self._should_skip_file(file_path):
                continue

            self.files_scanned += 1

            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                # Check each pattern
                for pattern in patterns:
                    matches = re.finditer(pattern, content, re.MULTILINE | re.IGNORECASE)

                    for match in matches:
                        # Calculate line number
                        line_number = content[:match.start()].count('\n') + 1

                        # Get code snippet (5 lines context)
                        lines = content.split('\n')
                        start_line = max(0, line_number - 3)
                        end_line = min(len(lines), line_number + 2)
                        code_snippet = '\n'.join(lines[start_line:end_line])

                        # Add vulnerability
                        vulnerability = {
                            "type": vuln_type,
                            "description": vuln_config["description"],
                            "severity": vuln_config["severity"],
                            "file": str(file_path.relative_to(self.repo_path)),
                            "line": line_number,
                            "matched_pattern": pattern,
                            "matched_text": match.group(0),
                            "code_snippet": code_snippet,
                            "remediation": self._get_remediation(vuln_type)
                        }

                        # Additional analysis for hardcoded secrets
                        if vuln_type == "hardcoded_secrets":
                            confidence = self._analyze_secret_confidence(match.group(0), content, line_number)
                            vulnerability["confidence"] = confidence
                            # Only report high confidence secrets
                            if confidence < 0.7:
                                continue

                        self.vulnerabilities_found.append(vulnerability)

            except Exception as e:
                # Log error but continue scanning
                print(f"Error scanning {file_path}: {str(e)}")

    def _should_skip_file(self, file_path: Path) -> bool:
        """Determine if file should be skipped"""
        skip_patterns = [
            ".git/", "node_modules/", "venv/", "env/", "__pycache__/",
            ".pytest_cache/", "build/", "dist/", ".next/", "target/",
            "vendor/", ".idea/", ".vscode/"
        ]

        file_str = str(file_path)
        return any(pattern in file_str for pattern in skip_patterns)

    def _analyze_secret_confidence(self, matched_text: str, full_content: str, line_number: int) -> float:
        """
        Analyze if a potential hardcoded secret is likely a real secret

        Returns confidence score 0.0-1.0
        """
        confidence = 0.5  # Base confidence

        # Higher confidence if not in test files
        if "test" not in matched_text.lower() and "example" not in matched_text.lower():
            confidence += 0.2

        # Higher confidence if looks like real credentials
        if re.search(r"[a-zA-Z0-9]{20,}", matched_text):  # Long random string
            confidence += 0.2

        # Lower confidence if in comments
        lines = full_content.split('\n')
        if line_number <= len(lines):
            line = lines[line_number - 1]
            if "#" in line or "//" in line or "/*" in line:
                confidence -= 0.3

        # Lower confidence for common placeholder values
        placeholders = ["your_api_key", "example", "dummy", "placeholder", "changeme", "password123"]
        if any(placeholder in matched_text.lower() for placeholder in placeholders):
            confidence -= 0.4

        return max(0.0, min(1.0, confidence))

    def _calculate_severity_breakdown(self) -> Dict[str, int]:
        """Calculate count of vulnerabilities by severity"""
        breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0}

        for vuln in self.vulnerabilities_found:
            severity = vuln.get("severity", "medium")
            breakdown[severity] = breakdown.get(severity, 0) + 1

        return breakdown

    def _get_remediation(self, vuln_type: str) -> str:
        """Get remediation advice for vulnerability type"""
        remediation_map = {
            "log4j": "Upgrade log4j to version 2.17.1 or later. Remove JNDI lookup capability if not needed.",
            "hardcoded_secrets": "Move credentials to environment variables or secret management system (e.g., Azure Key Vault, AWS Secrets Manager)",
            "sql_injection": "Use parameterized queries or ORM instead of string concatenation. Example: cursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))",
            "command_injection": "Avoid using os.system() or exec() with user input. Use subprocess with argument list instead of shell=True.",
            "xss_vulnerability": "Sanitize user input before rendering. Use framework's built-in XSS protection (e.g., React escapes by default, avoid dangerouslySetInnerHTML)",
            "insecure_random": "Use cryptographically secure random generator: Python's secrets module, Java's SecureRandom, Node's crypto.randomBytes()"
        }

        return remediation_map.get(vuln_type, "Review code and follow security best practices")


# Example usage and testing
if __name__ == "__main__":
    import asyncio

    async def test_scanner():
        # Test with current directory
        scanner = VulnerabilityScanner(".")
        results = await scanner.scan()

        print("=== Vulnerability Scan Results ===")
        print(f"Files scanned: {results['files_scanned']}")
        print(f"Files affected: {results['files_affected']}")
        print(f"Total vulnerabilities: {len(results['vulnerabilities_found'])}")
        print(f"\nSeverity breakdown:")
        for severity, count in results['severity_breakdown'].items():
            if count > 0:
                print(f"  {severity.upper()}: {count}")

        if results['vulnerabilities_found']:
            print(f"\n=== Top 5 Vulnerabilities ===")
            for vuln in results['vulnerabilities_found'][:5]:
                print(f"\n[{vuln['severity'].upper()}] {vuln['description']}")
                print(f"  File: {vuln['file']}:{vuln['line']}")
                print(f"  Matched: {vuln['matched_text'][:50]}")

    asyncio.run(test_scanner())
